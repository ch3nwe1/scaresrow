<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://ch3nwe1.github.io/scaresrow/java/JUC/ReentrantLock/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>ReentrantLock - 稻草人日记</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">稻草人日记</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">主页</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">程序 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">Python</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#">基础教程</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../python/基础教程/注释/">注释</a>
</li>
            
<li >
    <a href="../../../python/基础教程/元组与列表/">元组与列表</a>
</li>
            
<li >
    <a href="../../../python/基础教程/字符串/">字符串</a>
</li>
            
<li >
    <a href="../../../python/基础教程/字典/">字典</a>
</li>
            
<li >
    <a href="../../../python/基础教程/条件控制与循环结构/">条件控制和循环结构</a>
</li>
            
<li >
    <a href="../../../python/基础教程/函数/">函数</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Java</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../String/">字符串</a>
</li>
            
<li class="active">
    <a href="./">ReentrantLock</a>
</li>
            
<li >
    <a href="../Queue/">Queue</a>
</li>
            
<li >
    <a href="../BlockingQueue/">Blocking</a>
</li>
            
<li >
    <a href="../../Collection/PriorityQueue/">PriorityQueue</a>
</li>
            
<li >
    <a href="../ArrayBlockingQueue/">ArrayBlockingQueue</a>
</li>
            
<li >
    <a href="../DelayQueue/">DelayQueue</a>
</li>
            
<li >
    <a href="../PriorityBlockingQueue/">PriorityBlockingQueue</a>
</li>
            
<li >
    <a href="../FutureTask/">FutureTask</a>
</li>
            
<li >
    <a href="../ThreadPoolExecutor/">ThreadPoolExecutor</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#">jaxws</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../jaxws/jaxws-2.3.pdf">jaxws-2.3</a>
</li>
            
<li >
    <a href="../../jaxws/jax-ws-release-documentation.pdf">release-documentation</a>
</li>
            
<li >
    <a href="../../jaxws/JAXB-2.3-spec.pdf">jaxb</a>
</li>
            
<li >
    <a href="../../jaxws/jaxrs-2_1-final-spec.pdf">jaxrs</a>
</li>
            
<li >
    <a href="../../jaxws/jaxws-2_0-fr-spec.pdf">jaxws-2.0</a>
</li>
            
<li >
    <a href="../../jaxws/JSR181-2.1-MR.pdf">jsr</a>
</li>
            
<li >
    <a href="../../jaxws/Web Service Definition Language (WSDL).pdf">web service</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Redis</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../Redis/redis command/">redis command</a>
</li>
            
<li >
    <a href="../../../Redis/redis-replication/">redis-replication</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">VIM</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../VIM/vim/">VIM</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../about/">关于</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="../../String/">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="../Queue/">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#reentrantlock">ReentrantLock(可重入同步锁)</a></li>
            <li><a href="#_1">公平锁</a></li>
            <li><a href="#_2">不公平锁</a></li>
            <li><a href="#condition">Condition(线程的等待与唤醒)</a></li>
            <li><a href="#api">其他API</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="reentrantlock">ReentrantLock(可重入同步锁)</h1>
<p>​   ReentrantLock实现了Lock接口</p>
<pre><code class="java">//加锁
void lock();
</code></pre>

<pre><code class="java">//可中断的锁
void lockInterruptibly()
</code></pre>

<pre><code class="java">//尝试加锁,成功返回true,否则返回false
boolean tryLock();
</code></pre>

<pre><code class="java">//在指定时间内获取锁,如果获取成功返回true,否则返回false,如果线程被中断则抛出InterruptedException
boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
</code></pre>

<pre><code class="java">//释放锁
void unlock();
</code></pre>

<pre><code class="java">//返回 Condition实例,前提是当前线程必须拥有锁,用户线程等待或者唤醒的操作
Condition newCondition();
</code></pre>

<p>ReentrantLock同步锁中包含了公平锁和非公平锁,其底层是基于AQS实现的,我们分别研究下这两种锁是如何实现的.如何创建公平锁与非公平锁, 可以通过其构造器得知.</p>
<pre><code class="java">//默认是非公平锁
public ReentrantLock() {
    sync = new NonfairSync();
}
</code></pre>

<pre><code class="java">//true为公平锁,false为非公平锁
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>

<h2 id="_1">公平锁</h2>
<h3 id="lock">lock(加锁)</h3>
<pre><code class="java">public void lock() {
    //同步对象加锁
    sync.lock();
}
</code></pre>

<pre><code class="java">final void lock() {
    //获取一把锁
    acquire(1);
}
</code></pre>

<pre><code class="java">public final void acquire(int arg) {
    // tryAcquire方法尝试获取一把锁,如果返回true代表获取锁成功,如果获取失败,将当前线程添加到等待队列,并标    // 记独占模式,如果acquireQueued返回true代表线程需要中断
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        //如果线程中断状态为true,调用线程中断方法,原因是获取中断状态后,线程状态会被清理
        selfInterrupt();
}
</code></pre>

<pre><code class="java">//尝试获取锁
protected final boolean tryAcquire(int acquires) {
    //获取当前竞争锁的线程
    final Thread current = Thread.currentThread();
    //锁的状态,如果为0,代表处于空闲状态,大于0,其值代表锁的处理,在使用锁的阶段,加锁和释放锁都需要成对出现,
    //即调用lock()后需要调用unlock()来释放,每次加锁state+1,释放锁时state-1
    int c = getState();
    //如果锁状态为0,代表空闲
    if (c == 0) {
        //hasQueuedPredecessors()方法判断同步队列中是否有排在当前线程之前的线程竞争锁,这是公平锁的体现.
        //同步队列是使用FIFO的设计,即先进先出
        //compareAndSetState()方法使用CAS操作设置state值,返回true代表设置成功,这里为什么使用CAS操作,个人认为是一种悲观的体现,当前线程始终认为有其他线程在抢锁,所以自身也尝试竞争是否能够成功
        //setExclusiveOwnerThread()方法设置锁被独占的线程,最终返回true代表取锁成功
        if (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //判断当前线程是否与独占锁的线程是否相等,如果是同一个线程,允许获取锁,因为这是一个可重入的锁
    else if (current == getExclusiveOwnerThread()) {
        //加锁的次数
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        //设置state,这里为什么不使用CAS操作?因为当前线程已经持有锁,不会有其他线程竞争
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>

<pre><code class="java">public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    //判断当前线程在队列之前是否还有竞争者在排队,FIFO队列,首先的条件是head != tail 因为head和tail相等时队列是空的,其次判断head的next节点的线程不等于当前线程,代表当前线程不是排在第一个
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &amp;&amp;
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
</code></pre>

<pre><code class="java">//前面讲到如果tryAcquire(int)方法获取失败,会将当前线程添加到队列中等待,我们来看一看是如何添加到队列中的?
final boolean acquireQueued(final Node node, int arg) {
    //failed 属性是一个失败的标识,如果获取锁失败,取消当前线程去竞争锁,如果取消稍后解释
    boolean failed = true;
    try {
        //线程中断标识,如果为true,代表线程需要中断,在这个方法返回后调用
        boolean interrupted = false;
        //这里是自旋
        for (;;) {
            //获取当前线程的节点的前一个节点
            final Node p = node.predecessor();
            //如果前一个节点是头节点,则尝试获取锁,获取锁的结果决定当前线程的走向
            //1.获取锁成功,将当前节点设置为头节点,并返回
            if (p == head &amp;&amp; tryAcquire(arg)) {
                // head = node; node.thread = null; node.prev = null;
                setHead(node);
                p.next = null; // help GC 原来的head节点的next设置为null,取消与node的引用关系
                failed = false;// 取锁成功,failed设置为false
                return interrupted;//返回interrupted中断标识
            }
            //2.如果获取锁失败,判断当前是否应该挂起,如果应该挂起,则执行挂起,并判断线程是否中断
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        //如果失败,取消锁的竞争
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<pre><code class="java">//添加一个节点到等待队列, mode包含独占模式和共享模式
private Node addWaiter(Node mode) {
    //以指定模式创建当前的节点
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    //尝试将当前节点添加到队列末尾
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            //如果添加成功,返回当前节点
            return node;
        }
    }
    // compareAndSetTail() CAS操作设置tail节点失败后,通过enq()方法添加到tail节点,该方法是以自旋的方式直到添加成功为止
    enq(node);
    return node;
}
</code></pre>

<pre><code class="java">//将当前节点添加到队列的末尾
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            //如果tail节点未初始化,需要创建一个空节点来初始化队列
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>

<pre><code class="java">//判断node节点是否应该挂起
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    //前一个节点的等待状态
    int ws = pred.waitStatus;
    //如果是SIGNAL状态,返回true
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
    if (ws &gt; 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        //ws &gt; 0 代表该节点已经取消,向前查找未取消的节点,将队列拼接上,在这里有一个疑问,取消的节点已经离开队列,是否应该help GC一下呢?
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        //这里更新前一个节点的状态为SIGNAL,而没有返回true来挂起线程,为了重试获取锁确保当前线程没有成功才执行挂起
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>

<pre><code class="java">private final boolean parkAndCheckInterrupt() {
    //线程挂起
    LockSupport.park(this);
    //线程是否中断
    return Thread.interrupted();
}
</code></pre>

<pre><code class="java">private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    //如果节点为null,直接返回
    if (node == null)
        return;

    node.thread = null;//将当前节点的线程设置为null

    // Skip cancelled predecessors
    //获取当前节点的前一个节点,如果前一节点状态为是取消的,继续向前查找
    Node pred = node.prev;
    while (pred.waitStatus &gt; 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    //前一个节点的下一个节点
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    //标记当前节点的状态
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    //如果当前节点是tail节点,则更新前一节点为tail,并将前一个节点的next设置为null
    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        //1.前一节点不是head节点
        //2.前一个节点的状态SIGNAL或者状态小于等于0然后CAS更新为SIGNAL成功
        //3.前一个节点的线程不是空
        //以上条件满足,获取当前节点的下一个节点,此节点不是空并且状态小于等于0,将前一个节点与下一个节点拼起来
        if (pred != head &amp;&amp;
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;
            pred.thread != null) {
            Node next = node.next;
            if (next != null &amp;&amp; next.waitStatus &lt;= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
            //否则唤醒当前节点的下一个节点?
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
</code></pre>

<pre><code class="java">private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
</code></pre>

<h3 id="lockinterruptibly">lockInterruptibly(可中断加锁)</h3>
<pre><code class="java">public void lockInterruptibly() throws InterruptedException {
    sync.acquireInterruptibly(1);
}
</code></pre>

<pre><code class="java">public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    //如果线程中断,抛出中断异常
    if (Thread.interrupted())
        throw new InterruptedException();
    //尝试获取锁.如果失败,执行doAcquireInterruptibly()
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}
</code></pre>

<pre><code class="java">private void doAcquireInterruptibly(int arg)
    throws InterruptedException {
    //首先添加一个独占模式的线程节点到队列尾部
    final Node node = addWaiter(Node.EXCLUSIVE);
    //下面这些实现与acquireQueued()方法基本相同,唯一的区别是如果挂起的线程被唤醒后如果线程是中断状态则抛出中断异常
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h3 id="trylock">tryLock(尝试加锁)</h3>
<p>​   tryLock是不公平锁的一种体现,它获取锁的时候不会排队,在写到不公平锁的时候详细解释一下</p>
<pre><code class="java">public boolean tryLock() {
    return sync.nonfairTryAcquire(1);
}
</code></pre>

<pre><code class="java">final boolean nonfairTryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    int c = getState();
    //如果锁处于空闲,直接获取锁,并这是独占锁的线程为当前线程
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    //如果不是空闲,判断持有锁的线程是当前线程,添加锁的次数,获取锁成功,因为这是可重入锁
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    //其他情况都表示获取锁失败
    return false;
}
</code></pre>

<h3 id="trylock_1">tryLock(指定时间内尝试获取锁)</h3>
<pre><code class="java">public boolean tryLock(long timeout, TimeUnit unit)
        throws InterruptedException {
    //将事件转换为纳秒
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));
}
</code></pre>

<pre><code class="java">public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    //如果线程是中断状态,直接抛出中断异常
    if (Thread.interrupted())
        throw new InterruptedException();
    // 首先尝试获取锁,如果失败调用doAcquireNanos()
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}
</code></pre>

<pre><code class="java">private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    //超时时间如果小于等于0,直接获取锁失败
    if (nanosTimeout &lt;= 0L)
        return false;
    //结束时间
    final long deadline = System.nanoTime() + nanosTimeout;
    //添加一个独占的节点到队列的末尾
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        //自旋
        for (;;) {
            //获取当前节点的前一个节点
            final Node p = node.predecessor();
            //如果前一个节点是head节点,尝试获取锁,成功返回true
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            }
            //超时的结束时间与当前时间差,如果大于0代表还没有超时,继续自旋
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout &lt;= 0L)
                return false;
            //判断是否应该挂起线程,如果时间差大于1000L,将其挂起直到超时时间结束,再自旋开始最后获取一次锁
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                nanosTimeout &gt; spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        //如果获取锁失败了,取消当前线程在队列中的节点
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h3 id="unlock">unlock(释放锁)</h3>
<pre><code class="java">public void unlock() {
    sync.release(1);
}
</code></pre>

<pre><code class="java">public final boolean release(int arg) {
    //尝试释放锁,如果成功,唤醒下一个节点
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>

<pre><code class="java">protected final boolean tryRelease(int releases) {
    //将锁的state释放,即减去release的值
    int c = getState() - releases;
    //释放锁的前提是当前线程必须拥有锁
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    //空闲标识
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>

<h2 id="_2">不公平锁</h2>
<h3 id="lock_1">lock(加锁)</h3>
<pre><code class="java">//首先直接去获取锁,这里没有尝试,如果失败再尝试获取通过调用tryAcquire
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
</code></pre>

<pre><code class="java">protected final boolean tryAcquire(int acquires) {
    //前文已经解释过了,nonfairTryAcquire()方法如果锁空闲,直接获取锁,而公平锁则是查看前面是否有排队的线程
    return nonfairTryAcquire(acquires);
}
</code></pre>

<h2 id="condition">Condition(线程的等待与唤醒)</h2>
<pre><code class="java">//线程等待,可中断
void await() throws InterruptedException;
</code></pre>

<pre><code class="java">//不可中断的等待
void awaitUninterruptibly();
</code></pre>

<pre><code class="java">long awaitNanos(long nanosTimeout) throws InterruptedException;
</code></pre>

<pre><code class="java">boolean await(long time, TimeUnit unit) throws InterruptedException;
</code></pre>

<pre><code class="java">boolean awaitUntil(Date deadline) throws InterruptedException;
</code></pre>

<pre><code class="java">void signal();
</code></pre>

<pre><code class="java">void signalAll();
</code></pre>

<h3 id="await">await</h3>
<pre><code class="java">public final void await() throws InterruptedException {
    // 首先线程如果是中断状态, 抛出InterruptedException异常
    if (Thread.interrupted())
        throw new InterruptedException();
    //添加到等待队列
    Node node = addConditionWaiter();
    //释放当前线程持有的锁
    int savedState = fullyRelease(node);
    //中断方式:1.THROW_IE,抛出中断异常2.REINTERRUPT,调用线程的中断方法
    int interruptMode = 0;
    //判断是否在同步队列,如果不在同步队列,线程挂起等待.
    //??? 为什么这个节点会在同步队列中呢?我苦思这段代码,终于再后面知道了(ps:当然是在调用唤醒方法的时候啦)
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        //检查线程在等待期间是否中断,不为0代表中断
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // acquireQueued方法将当前节点添加到同步队列中,返回true,代表线程中断
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
</code></pre>

<pre><code class="java">private Node addConditionWaiter() {
    //获取最后一个等待者
    Node t = lastWaiter;
    // If lastWaiter is cancelled, clean out.
    //如果最后一个等待线程不是null并且节点的状态不是CONDITION,清理已经取消的等待线程
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        //删除非Condition的节点
        unlinkCancelledWaiters();
        //重新赋值t
        t = lastWaiter;
    }
    //创建一个Condition状态的节点
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    //如果队列为空firstWaiter = lastWaiter = node,否则t.nextWaiter = node
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}
</code></pre>

<pre><code class="java">//清理已经取消的等待线程
private void unlinkCancelledWaiters() {
    //队列第一个节点
    Node t = firstWaiter;
    //遍历过的最后一个非Condition节点,也可以说是当前遍历节点的前一个节点,因为Condition Queue是一个单向链表
    Node trail = null;
    while (t != null) {
        //下一个等待节点
        Node next = t.nextWaiter;
        //节点的等待状态不是CONDITION
        if (t.waitStatus != Node.CONDITION) {
            //断开当前节点与下一节点的链接
            t.nextWaiter = null;
            //如果前一个节点为null,更新next为第一个等待队列,否则next节点为trail的nextWaiter
            if (trail == null)
                firstWaiter = next;
            else
                trail.nextWaiter = next;
            //如果next为null,代表已经到了最后,更新lastWaiter为trail,因为t节点的状态不是CONDITION
            if (next == null)
                lastWaiter = trail;
        }
        else
            trail = t;
        t = next;
    }
}
</code></pre>

<pre><code class="java">//线程等待期间将线程持有的重入锁全部释放, 如果失败将节点的状态waitStatus设置为CANCELLED
final int fullyRelease(Node node) {
    boolean failed = true;
    try {
        int savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}
</code></pre>

<pre><code class="java">//判断是否在同步队列
//1.节点的waitStatus等于CONDITION, 并且前一节点为null,则返回false,因为这是Condition Queue
final boolean isOnSyncQueue(Node node) {
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    if (node.next != null) // If has successor, it must be on queue
        return true;
    //从队列最后向前查找该节点
    return findNodeFromTail(node);
}
</code></pre>

<pre><code class="java">private int checkInterruptWhileWaiting(Node node) {
    //如果线程中断,返回transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT,否则为0
    return Thread.interrupted() ?
        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :
        0;
}
</code></pre>

<pre><code class="java">//线程中断后,不必再等待,将该节点转化为Sync Queue,并添加到队列末尾
final boolean transferAfterCancelledWait(Node node) {
    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {
        enq(node);
        return true;
    }
    /*
     * If we lost out to a signal(), then we can't proceed
     * until it finishes its enq().  Cancelling during an
     * incomplete transfer is both rare and transient, so just
     * spin.
     */
    //如果不在同步队列中,线程让步
    while (!isOnSyncQueue(node))
        Thread.yield();
    return false;
}
</code></pre>

<h3 id="awaituninterruptibly">awaitUninterruptibly</h3>
<pre><code class="java">//不会抛出异常的线程等待
public final void awaitUninterruptibly() {
    //添加一个等待节点到Condition Queue
    Node node = addConditionWaiter();
    //释放锁
    int savedState = fullyRelease(node);
    boolean interrupted = false;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if (Thread.interrupted())
            interrupted = true;
    }
    //如果线程中断恢复中断状态
    if (acquireQueued(node, savedState) || interrupted)
        selfInterrupt();
}
</code></pre>

<h3 id="awaitnanosnanostimeout">awaitNanos(nanosTimeout)</h3>
<pre><code class="java">// 指定超时时间的等待
public final long awaitNanos(long nanosTimeout)
        throws InterruptedException {
    //如果线程中断,直接抛出异常
    if (Thread.interrupted())
        throw new InterruptedException();
    //添加一个等待节点到Condition Queue中
    Node node = addConditionWaiter();
    //先释放锁
    int savedState = fullyRelease(node);
    //线程等待的结束日期
    final long deadline = System.nanoTime() + nanosTimeout;
    int interruptMode = 0;
    //首先判断是否在同步队列中
    while (!isOnSyncQueue(node)) {
        //如果超时时间小于等于0,取消等待,然后将当前节点添加到Sync Deque中
        if (nanosTimeout &lt;= 0L) {
            transferAfterCancelledWait(node);
            break;
        }
        //如果超时时间超过1000,线程挂起,直到超时时间结束
        if (nanosTimeout &gt;= spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanosTimeout);
        //如果线程中断,直接跳出循环
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
        nanosTimeout = deadline - System.nanoTime();
    }
    //获取锁,如果中断,报告
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    //清理Condition Queue
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
    //返回等待剩余的时间
    return deadline - System.nanoTime();
}
</code></pre>

<h3 id="awaitlong-time-timeunit-unit">await(long time, TimeUnit unit)</h3>
<pre><code class="java">// 此处实现与awaitNanos大致相同,主要在其返回值代表是否超时,如果提前唤醒返回true
public final boolean await(long time, TimeUnit unit)
        throws InterruptedException {
    long nanosTimeout = unit.toNanos(time);
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    final long deadline = System.nanoTime() + nanosTimeout;
    boolean timedout = false;
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        if (nanosTimeout &lt;= 0L) {
            //这里可能等待节点被提前唤醒,导致节点转化失败
            timedout = transferAfterCancelledWait(node);
            break;
        }
        if (nanosTimeout &gt;= spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanosTimeout);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
        nanosTimeout = deadline - System.nanoTime();
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
    return !timedout;
}
</code></pre>

<h3 id="awaituntildate-deadline">awaitUntil(Date deadline)</h3>
<pre><code class="java">public final boolean awaitUntil(Date deadline)
        throws InterruptedException {
    //绝对日期 以毫秒为单位
    long abstime = deadline.getTime();
    if (Thread.interrupted())
        throw new InterruptedException();
    Node node = addConditionWaiter();
    int savedState = fullyRelease(node);
    boolean timedout = false;
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        if (System.currentTimeMillis() &gt; abstime) {
            timedout = transferAfterCancelledWait(node);
            break;
        }
        LockSupport.parkUntil(this, abstime);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
    return !timedout;
}
</code></pre>

<h3 id="signal">signal</h3>
<pre><code class="java">public final void signal() {
    //必须是独占模式,当前线程必须持有锁
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    //唤醒第一个等待节点
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}
</code></pre>

<pre><code class="java">private void doSignal(Node first) {
    do {
        //将第一个节点更新为第二个节点,如果第二个节点为null,说明Condition Queue是空的,需要更新             //lastWaiter为null
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        //断开与其他节点的链接
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;&amp;
             (first = firstWaiter) != null);//转换节点状态,并添加到同步队列,如果失败,返回false,继续唤醒下一个等待的节点
}
</code></pre>

<pre><code class="java">//转换这个节点到Sync Queue
final boolean transferForSignal(Node node) {
    /*
     * If cannot change waitStatus, the node has been cancelled.
     */
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;

    /*
     * Splice onto queue and try to set waitStatus of predecessor to
     * indicate that thread is (probably) waiting. If cancelled or
     * attempt to set waitStatus fails, wake up to resync (in which
     * case the waitStatus can be transiently and harmlessly wrong).
     */
    //添加到同步队列的末尾,并返回前一节点,如果前一个节点状态是取消的或者更新状态失败,唤醒该线程来重新同步
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}
</code></pre>

<h3 id="signalall">signalAll</h3>
<pre><code class="java">public final void signalAll() {
    //判断当前线程是否持有锁
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    //唤醒所有节点
    if (first != null)
        doSignalAll(first);
}
</code></pre>

<pre><code class="java">//单向队列依次唤醒所有等待的节点
private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}
</code></pre>

<h2 id="api">其他API</h2>
<h3 id="getholdcount">getHoldCount</h3>
<pre><code class="java">public int getHoldCount() {
    return sync.getHoldCount();
}
</code></pre>

<pre><code class="java">final int getHoldCount() {
    //如果当前线程持有锁,返回state的值,否则为0
    return isHeldExclusively() ? getState() : 0;
}
</code></pre>

<h3 id="isheldbycurrentthread">isHeldByCurrentThread</h3>
<pre><code class="java">public boolean isHeldByCurrentThread() {
    //判断当前线程是否持有锁
    return sync.isHeldExclusively();
}
</code></pre>

<h3 id="islocked">isLocked</h3>
<blockquote>
<p>锁是否空闲,以state值是否为0判断</p>
</blockquote>
<pre><code class="java">public boolean isLocked() {
    return sync.isLocked();
}
</code></pre>

<h3 id="isfair">isFair</h3>
<blockquote>
<p>是否为公平锁</p>
<p><code>java
public final boolean isFair() {
    return sync instanceof FairSync;
}</code></p>
</blockquote>
<h3 id="getowner">getOwner</h3>
<blockquote>
<p>获取锁持有的线程,如果锁空闲返回null</p>
<p><code>java
final Thread getOwner() {
    return getState() == 0 ? null : getExclusiveOwnerThread();
}</code></p>
</blockquote>
<h3 id="hasqueuedthreads">hasQueuedThreads</h3>
<blockquote>
<p>是否有排队的线程</p>
<p><code>java
public final boolean hasQueuedThreads() {
    return head != tail;
}</code></p>
</blockquote>
<h3 id="hasqueuedthread">hasQueuedThread</h3>
<blockquote>
<p>判断该线程是否在排队</p>
<p><code>java
public final boolean hasQueuedThread(Thread thread) {
    return sync.isQueued(thread);
}</code></p>
<p><code>java
public final boolean isQueued(Thread thread) {
    if (thread == null)
        throw new NullPointerException();
    for (Node p = tail; p != null; p = p.prev)
        if (p.thread == thread)
            return true;
    return false;
}</code></p>
</blockquote>
<h3 id="getqueuelength">getQueueLength</h3>
<blockquote>
<p>同步队列的长度</p>
<p><code>java
public final int getQueueLength() {
    return sync.getQueueLength();
}</code></p>
<p><code>java
public final int getQueueLength() {
    int n = 0;
    for (Node p = tail; p != null; p = p.prev) {
        if (p.thread != null)
            ++n;
    }
    return n;
}</code></p>
</blockquote>
<h3 id="getqueuedthreads">getQueuedThreads</h3>
<blockquote>
<p>获取所有排队的线程</p>
<p><code>java
protected Collection&lt;Thread&gt; getQueuedThreads() {
    return sync.getQueuedThreads();
}</code></p>
<p><code>java
public final Collection&lt;Thread&gt; getQueuedThreads() {
    ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;();
    for (Node p = tail; p != null; p = p.prev) {
        Thread t = p.thread;
        if (t != null)
            list.add(t);
    }
    return list;
}</code></p>
</blockquote>
<h3 id="haswaiters">hasWaiters</h3>
<blockquote>
<p>是否由线程等待</p>
<p><code>java
public boolean hasWaiters(Condition condition) {
    if (condition == null)
        throw new NullPointerException();
    if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))
        throw new IllegalArgumentException("not owner");
    return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);
}</code></p>
<p><code>java
public final boolean hasWaiters(ConditionObject condition) {
    if (!owns(condition))
        throw new IllegalArgumentException("Not owner");
    return condition.hasWaiters();
}</code></p>
<p><code>java
protected final boolean hasWaiters() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    for (Node w = firstWaiter; w != null; w = w.nextWaiter) {
        if (w.waitStatus == Node.CONDITION)
            return true;
    }
    return false;
}</code></p>
</blockquote>
<h3 id="getwaitqueuelength">getWaitQueueLength</h3>
<blockquote>
<p>Condition Queue的长度</p>
</blockquote>
<h3 id="getwaitingthreads">getWaitingThreads</h3>
<blockquote>
<p>Condition Queue中所有等待的线程</p>
</blockquote></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
