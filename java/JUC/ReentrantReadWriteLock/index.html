<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        <link rel="canonical" href="https://ch3nwe1.github.io/scaresrow/java/JUC/ReentrantReadWriteLock/">
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>ReentrantReadWriteLock(可重入读写锁) - 稻草人日记</title>
        <link href="../../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../../..">稻草人日记</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../../..">主页</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">程序 <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
  <li class="dropdown-submenu">
    <a href="#">Python</a>
    <ul class="dropdown-menu">
            
  <li class="dropdown-submenu">
    <a href="#">基础教程</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../python/基础教程/注释/">注释</a>
</li>
            
<li >
    <a href="../../../python/基础教程/元组与列表/">元组与列表</a>
</li>
            
<li >
    <a href="../../../python/基础教程/字符串/">字符串</a>
</li>
            
<li >
    <a href="../../../python/基础教程/字典/">字典</a>
</li>
            
<li >
    <a href="../../../python/基础教程/条件控制与循环结构/">条件控制和循环结构</a>
</li>
            
<li >
    <a href="../../../python/基础教程/函数/">函数</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Java</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../String/">字符串</a>
</li>
            
<li >
    <a href="../ReentrantLock/">ReentrantLock</a>
</li>
            
<li >
    <a href="../Queue/">Queue</a>
</li>
            
<li >
    <a href="/java/JUC/BlockingQueue.md">Blocking</a>
</li>
            
<li >
    <a href="/java/Collection/PriorityQueue.md">PriorityQueue</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#">Redis</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../../../redis-replication Redis/redis-replication.md">None</a>
</li>
    </ul>
  </li>
                                </ul>
                            </li>
                            <li >
                                <a href="../../../about/">关于</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#reentrantreadwritelock">ReentrantReadWriteLock(可重入读写锁)</a></li>
            <li><a href="#readwritelock-api">ReadWriteLock API</a></li>
            <li><a href="#readlock">ReadLock</a></li>
            <li><a href="#writelock">WriteLock</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="reentrantreadwritelock">ReentrantReadWriteLock(可重入读写锁)</h1>
<blockquote>
<p>ReentrantLock是独占式可重入排它锁,也就是说只有一个线程持有锁,其他线程需要等待持锁线程释放后才能获得,但是在实际场景中,如果多个线程访问共享资源时只是读取的,这实际上是线程安全的,没有必要等待线程释放锁.所以,此类设计实为读写分离的设计.如果锁属于读锁,那其他线程是可以获取的.属于共享锁的性质.同样也是基于AQS实现其ReadWriteLock接口功能的锁</p>
</blockquote>
<h2 id="readwritelock-api">ReadWriteLock API</h2>
<pre><code class="java">//获取读锁
Lock readLock();
</code></pre>

<pre><code class="java">//获取写锁
Lock writeLock();
</code></pre>

<blockquote>
<p>这两个API的实现亦是简单关键在于其接口返回的lock对象是如何实现的,让我们一步一步接口他的面纱</p>
</blockquote>
<pre><code class="java">public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}

public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
</code></pre>

<h2 id="readlock">ReadLock</h2>
<h3 id="lock">lock</h3>
<pre><code class="java">public void lock() {
    sync.acquireShared(1);
}
</code></pre>

<pre><code class="java">public final void acquireShared(int arg) {
    //首先尝试获取共享锁,返回值为1 代表成功 -1 代表失败
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}
</code></pre>

<pre><code class="java">protected final int tryAcquireShared(int unused) {
    //获取当前的线程
    Thread current = Thread.currentThread();
    int c = getState();
    //首先判断是否有写入锁, 如果有写入锁并且不是当前的线程持有写入锁,直接返回-1,获取失败
    if (exclusiveCount(c) != 0 &amp;&amp;
        getExclusiveOwnerThread() != current)
        return -1;
    //获取读锁的数量
    int r = sharedCount(c);
    //readerShouldBlock方法判断是否应该阻塞,该方法实现取决于公平锁与非公平锁的实现而异,如果是公平锁,需要
    //查找队列中的第一个线程是不是自身的线程,非公平锁需要判断同步队列的第一个线程是否独占模式的线程,如果是独    //占线程,返回true,获取锁应该阻塞,否则返回false
    if (!readerShouldBlock() &amp;&amp;
        r &lt; MAX_COUNT &amp;&amp; // 锁的数量小于65535
        compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            //如果是第一次读取,更新firstReader为当前线程,记录第一次获取读锁的线程和数量
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            //如果不为0,并且当前线程为第一次获取读锁的线程,更新读锁的数量
            firstReaderHoldCount++;
        } else {
            //如果锁的数量不为0,并且不是第一个读锁的线程,需要缓存当前线程持有锁的数量
            HoldCounter rh = cachedHoldCounter;//最后一个读锁线程持有的数量
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}

final int fullTryAcquireShared(Thread current) {
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        // 如果存在独占锁,并且不为当前线程,直接返回-1
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;
            // else we hold the exclusive lock; blocking here
            // would cause deadlock.
        } else if (readerShouldBlock()) {
            //如果读锁应该阻塞,并且当前线程不是第一个读锁的线程,当前线程持有锁的数量等于0,返回-1.失败
            //这里为什么当前线程持有锁的数量为0,为什么宣布失败呢?
            // Make sure we're not acquiring read lock reentrantly
            if (firstReader == current) {
                // assert firstReaderHoldCount &gt; 0;
            } else {
                if (rh == null) {
                    rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current)) {
                        rh = readHolds.get();
                        if (rh.count == 0)
                            readHolds.remove();
                    }
                }
                if (rh.count == 0)
                    return -1;
            }
        }
        //如果共享锁超过了最大数量,抛出异常
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        //CAS设置state成功,则获取锁成功
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            if (sharedCount(c) == 0) {
                firstReader = current;
                firstReaderHoldCount = 1;
            } else if (firstReader == current) {
                firstReaderHoldCount++;
            } else {
                if (rh == null)
                    rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                else if (rh.count == 0)
                    readHolds.set(rh);
                rh.count++;
                cachedHoldCounter = rh; // cache for release
            }
            return 1;
        }
    }
}
</code></pre>

<pre><code class="java">//EXCLUSIVE_MASK (1 &lt;&lt; SHARED_SHIFT) - 1 = 65535 = 0x7fff
//state是一个int类型的值,共32位,前16位代表写入锁的数量,后16位代表读锁的数量
//readLock负责后面16位的改变,writeLock负责前16位的值
//这里是c &amp; 0x7fff 明显是取前16位的值,以此来判断是否有写入锁
static int exclusiveCount(int c) { return c &amp; EXCLUSIVE_MASK; }
//state无符号右移16位,取读锁的数量
static int sharedCount(int c)    { return c &gt;&gt;&gt; SHARED_SHIFT; }
</code></pre>

<pre><code class="java">//公平锁读取时是否应该阻塞,取决于队列之前是否有线程等待,究竟何时会有线程添加到队列中?先不着急,后面肯定会有
final boolean readerShouldBlock() {
    return hasQueuedPredecessors();
}
</code></pre>

<pre><code class="java">//非公平锁判断线程是否应该阻塞
final boolean readerShouldBlock() {
    return apparentlyFirstQueuedIsExclusive();
}
//判断队列中的第一个线程是否独占,为了防止写线程饥饿等待
final boolean apparentlyFirstQueuedIsExclusive() {
    Node h, s;
    return (h = head) != null &amp;&amp;
        (s = h.next)  != null &amp;&amp;
        !s.isShared()         &amp;&amp;
        s.thread != null;
}
</code></pre>

<pre><code class="java">//当尝试获取共享锁失败时,添加到等待队列,自旋获取锁
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            //如果前一个节点是头节点,尝试获取共享锁
            if (p == head) {
                int r = tryAcquireShared(arg);
                //设置共享锁成功后
                if (r &gt;= 0) {
                    //当前节点设置为头节点,并传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>

<h3 id="unlock">unlock</h3>
<pre><code class="java">public final boolean releaseShared(int arg) {
    //尝试释放共享锁,如果共享锁没有被全部的线程释放,调用doReleaseShared()向下传播释放
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre>

<pre><code class="java">protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    //与第一个读锁的线程比较,根据读锁的重入次数,处理缓存
    if (firstReader == current) {
        // assert firstReaderHoldCount &gt; 0;
        if (firstReaderHoldCount == 1)
            firstReader = null;
        else
            firstReaderHoldCount--;
    } else {
        //更新线程持有重入读锁的缓存
        HoldCounter rh = cachedHoldCounter;
        if (rh == null || rh.tid != getThreadId(current))
            rh = readHolds.get();
        int count = rh.count;
        if (count &lt;= 1) {
            readHolds.remove();
            if (count &lt;= 0)
                throw unmatchedUnlockException();
        }
        --rh.count;
    }
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        //CAS循环释放锁,因为读锁不属于排他锁,所以可能存在多个线程释放锁
        if (compareAndSetState(c, nextc))
            // Releasing the read lock has no effect on readers,
            // but it may allow waiting writers to proceed if
            // both read and write locks are now free.
            return nextc == 0;//如果为0代表锁空闲
    }
}
</code></pre>

<pre><code class="java">//循环释放共享锁
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
</code></pre>

<h2 id="writelock">WriteLock</h2>
<h3 id="lock_1">lock</h3>
<pre><code class="java">public final void acquire(int arg) {
    //尝试获取独占锁,如果失败,添加到同步队列等待唤醒
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>

<pre><code class="java">protected final boolean tryAcquire(int acquires) {
    /*
     * Walkthrough:
     * 1. 如果共享锁的数量不为0,获取独占锁的线程不为当前线程,获取失败
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        //如果state不为0,独占锁的数量为0,共享锁的数量一定不是0
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        // w不为0,并且为当前线程持有独占锁,则重入,这里不用CAS操作,是因为当前线程已经获取了锁
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    //如果不阻塞并且CAS设置state成功,代表获取锁成功,设置独占锁的线程
    setExclusiveOwnerThread(current);
    return true;
}
</code></pre>

<pre><code class="java">// FairLock impliments writerShouldBlock
// 判断同步队列的第一个节点为null或者 不是当前线程
final boolean writerShouldBlock() {
    return hasQueuedPredecessors();
}
//always false,意味者随时插队
final boolean writerShouldBlock() {
    return false; // writers can always barge
}
</code></pre>

<h3 id="unlock_1">unlock</h3>
<pre><code class="java">public final boolean release(int arg) {
    //释放锁,并唤醒下一个节点
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
</code></pre>

<pre><code class="java">protected final boolean tryRelease(int releases) {
    //判断当前线程是否拥有独占锁
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    //锁释放, 更新state
    int nextc = getState() - releases;
    boolean free = exclusiveCount(nextc) == 0;
    if (free)
        setExclusiveOwnerThread(null);
    setState(nextc);
    return free;
}
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../../js/base.js" defer></script>
        <script src="../../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
